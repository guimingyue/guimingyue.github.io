---
layout: post
title: Effective Java 读书笔记 - 第五章
category: Effective Java
---
Java 1.5 版本新增了泛型，但是又增加了 Java 程序的复杂度，这章介绍如何最大化的利用泛型，同时简化开发。

## 不要使用原生类型

比如在使用`List`接口时，不要直接`new ArrayList()`，而应该`new ArrayList<Object>()`，因为后者可以在编译期检查添加到`List`中的元素是否时同一种类型，前者极易导致运行时的`ClassCastException`。

由于 Java 中所有的对象都是`Object`的对象，那么`List`和`List<Object>`是否等价呢？显然不等价，因为，编译器不会对`List`进行类型检查，而`List<Object>`则告诉编译器可以接受任何类型的对象，但是如果定义了一个方法，这个方法的一个参数是`List<Object>`，如果在调用该方法时，传递了`List<String>`类型的参数，编译不会通过。

```java
public static void main(String[] args) {
    List<String> strings = new ArrayList<String>();
    unsafeAdd(strings, new Integer(42));
    String s = strings.get(0);// 1
    unsafeAddGeneric(strings, new Integer(43)); // 2
}

public static void unsafeAdd(List list, Object object) {
    list.add(object);
}

public static void unsafeAddGeneric(List<Object> list, Object object) {
    list.add(object);
}
```
这段代码中 1 处编译通过，但是在运行时会报`ClassCastException`。2 处编译不通过，报错信息为
```java
The method unsafeAddGeneric(List<Object>, Object) in the type Generic is not applicable for the arguments (List<String>, Integer)
```

Java 1.5 为泛型提供了通配符类型（`?`），如果要使用泛型，但不确定或者不关心具体类型，就可以使用通配符类型，如`List<?>`。那么带通配符的泛型和原生类型有什么区别呢？带通配符的泛型时类型安全的，如无法将任何一种类型（除`null`外）添加到该类型的集合中。

```java
public static void wildcardAdd(Collection<?> collection, Object object) {
    collection.add(object);
}
```
这段代码中，`collection.add(object)`编译不通过。报错信息如下。
```java
The method add(capture#1-of ?) in the type Collection<capture#1-of ?> is not applicable for the arguments (Object)
```

目前有两种情况必须使用原生类型。
1. 在使用支持泛型的类的`class`类时，例如不能使用`List<String>.class`和`List<?>.class`，而必须使用`List.class`。因为 Java 代码在编译之后，泛型的类型参数被擦出了，所以无法知道`class`对象的参数类型。
2. 在使用`instanceOf`操作符时，如`o instanceOf Set`，因为类型参数被擦除了。

## 消除非受检查警告