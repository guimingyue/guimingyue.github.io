---
layout: post
title: Effective Java 读书笔记 - 第二章
category: Effective Java
---

这一章主要介绍了对象的创建和销毁。包括：
* 何时创建对象；
* 如何创建对象；
* 何时应该避免创建不必要的对象；
* 如何避免创建必须要的对象；
* 如何确保对象适时的销毁；
* 如何管理对象销毁时的清理操作。

## Item 1：使用静态工厂方法替代构造函数

除了使用构造函数获取对象以外，还有另一种方式可以用于获取对象，那就是__静态工厂方法__。比如`Boolean.valueOf(Boolean b)`方法。

```

```

相较于构造方法，静态工厂方法有如下优势：

1. 静态工厂方法拥有明确的方法名。
  如果静态工厂方法名恰到好处，API 的使用者可以很容易的使用这个方法并且写出来的代码更易读，比如 `BigInteger(int, int, Randong)`，这个构造函数返回一个 BigInteger 对象，它的值可能是一个素数，达到这个目的，但是更合适的方式是调用`BigInteger.probablePrime(int , Random)`这个静态工厂方法。通过方法名可以明确的向调用者屏蔽多参构造方法，从而使得接口类更易使用。
2. 静态工厂方法不会可以复用已经创建的对象。
  单例模式正式通过这种方式返回单一对象的。
3. 静态工厂方法可以返回一个类型的任意子类型。
  如果希望通过隐藏具体的实现细节从而提供简洁的 API，通过静态工厂方法可以很方便的实现，基于接口的框架技术正是这种方法的典型应用：接口为静态工厂方法提供了返回类型 `Type`，但是接口不能有静态方法，所以接口的静态方法定义在名为 `Types` 的类中（该类无法实例化），例如`java.util.Collections`。
  通过这种方式也可以根据参数确定具体使用的实现类，而隐藏具体的实现，例如`java.util.EnumSet`类的`noneOf()`方法，它会根据每次传入的枚举类型的值来确定使用`RegularEnumSet`还是`JumboEnumSet`实现类，而这种实现类对使用者是不可见的。
  静态工厂方法返回的对象类型在静态工厂类编写的时候，甚至可以不必存在，而是后续再提供，这就构成了_服务提供框架_的基础。例如 JDBC 中，`Connection`类是静态工厂方法`DriverManager.getConnection()`需要返回的接口类，但是具体的`Connection`子类需要实现 JDBC 规范的数据库厂商来提供，而 JDBC 服务的提供，需要实现服务提供接口`Driver`，并将这个接口通过`DriverManager.registerDriver()`进行注册。
 4. 静态工厂方法可以减少代码冗余。
   如果正常的创建一个指定类型参数的 HashMap，使用构造方法的代码如下：
   ```
    Map<String, List<String>> map = new HashMap<String, List<String>>();
   ```
   如果需要构造多个这样的对象，显然代码冗长，所以可以定义一个静态工厂方法：
   ```
   public static <K, V> HashMap<K, V> newInstance() {
        return new HashMap<K, V>();
    }
   ```
   再构造一个`HashMap`对象就只需要调用`newInstance`方法了。

## Item 2：使用构建器替代多个参数的构造方法

静态工厂方法和构造方法有一个共同的缺陷，即一个类在有很多可选参数的情况下，很难扩展，而构造函数针对这种情况，只能定义多个重载方法来接受不同的可选参数，然而如果可选参数的类型大部分都一致，就会造成误用的情况。另外针对这种情况，也可以使用 Java Bean 的方式解决，但是 Java Bean 代码冗长，而且容易遗漏部分的参数设置，此外 Java Bean 无法构造不可变对象。
针对这种可选参数过多的需求，构建器（Builder）是一个相对合适的选择，如类 `NutritionFacts` 的源码所示。

```
//构建器
public class NutritionFacts {

    // Required
    private final int servingSize;
    private final int servings;
    // Optional
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public static class Builder {
        private final int servingSize;
        private final int servings;
        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;
        private int carbohydrate = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val) {
            this.calories = val;
            return this;
        }

        public Builder fat(int val) {
            this.fat = val;
            return this;
        }

        public Builder carbohydrate(int val) {
            this.carbohydrate = val;
            return this;
        }

        public Builder sodium(int val) {
            this.sodium = val;
            return this;
        }

        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        this.servingSize = builder.servingSize;
        this.servings = builder.servings;
        this.calories = builder.calories;
        this.fat = builder.fat;
        this.sodium = builder.sodium;
        this.carbohydrate = builder.carbohydrate;
    }
}
```

## Item 3：使用私有构造方法或枚举类型强化单例属性

## Item 4：使用私有构造方法禁止类被实例化

## Item 5：避免创建必须要的对象


## Item 6：消除过期的对象引用

## Item 7：避免使用`finalize`方法
