---
layout: post
title: Effective Java 读书笔记 - 第三章
category: Effective Java
---
这一章主要介绍了如何覆盖`Object`的非`final`方法和`Comparable.compareTo`方法。

## 如何重写`equals`方法

当一个类具有特定的逻辑相等的概念而不是对象等同（即`obj1 == obj2`）时，类的编写者就需要考虑重写`equals`方法，但是不恰当的重写`equals`方法容易导致一些问题，所以在重写`equals`方法时，应该遵守一些通用的约定。

1. 自反性，即 `x.equals(x)` 为`true`。
2. 对称性，即 `x.equals(y)` 为`true` 的充要条件是`y.equals(x)`为`true`。
3. 传递性，即 `x.equals(y)`为`true`，`y.equals(z)`为`true`，那么`x.equals(z)` 也为 `true`。
4. 一致性，即在没有对 x 和 y，做任何修改的情况下，任何时候调用`x.equals(y)`的值应该是一致的。
5. 对于一个非`null`的引用，`x.equals(null)`必须是`false`。

自反性要求一个对象比如等价于自身。对称性涉及两个对象之间的比较，假如实现一个`CaseInsensitiveString`类，并重写`equals`方法。

```
public class CaseInsensitiveString {
    private final String s;

    public CaseInsensitiveString(String s) {
        this.s = s;
    }

    @Override
    public boolean equals(Object o) {
        if ((o instanceof CaseInsensitiveString)) {
            return ((CaseInsensitiveString)o).s.equalsIgnoreCase(s);
        }
        if(o instanceof String) {
            return s.equalsIgnoreCase((String)o);
        }
        return false;
    }
}
``` 
在重写的`equals`方法中，判断了比较对象是否是`String`类型，显然这会违反对称性，因为`String.equals(CaseInsensitiveString)`一定会返回`false`，而`CaseInsensitiveString.equals(String)`可能会返回`true`。
传递性涉及 3 个对象之间的比较，考虑这样的情形，`Point`类有两个整型变量，表示二维平面的坐标，而`colorPoint`类继承自`Point`类，它增加了一个`color`属性。

```


```
为了不违反对称性，如果`Point.equals(ColorPoint)`为`true`，`ColorPoint.equals(Point)`必须为`true`，所以`ColorPoint`的`equals`方法可以是这样的。

```

```

上代码创建的 3 个对象可以看出，这样就违反了传递性，所以没法继承一个对象并且添加一个值后，仍然能遵守`equals`方法的约定。
针对这种情况，可以使用_组合优于继承_的原则，将`ColorPoint`改写成这样。

```
// Composition

```
一致性要求在两个对象没有变更过的情况下，任何一次调用`equals`方法的结果必须是一样的。无论是可变对象还是不可变对象，`equals`方法不能依赖不可靠的资源。

下面这些诀窍有助于实现高质量的`equals`方法。

1. 首先使用`==`操作符检查参数的引用是否就是当前的对象。
2. 使用`instanceof`操作符检查参数是否是正确的类型，因为`equals`方法的参数类型是`Object`。
3. 在比较前将参数强制转换成正确的类型。
4. 在两个对象检查每个待比较的成员变量是否匹配。
在比较时，对于除`float`和`double`的基本类型，使用`==`操作符，对于引用，调用它们的`equals`进行比较，对于数组类型则需要比较每个元素（可以调用`Arrays.equals()`的重载方法），对于`float`和`double`类型，使用其包装类型的`compare`进行比较。
5. 在完成`equals`方法之后检查它是否遵守了`equals`方法的约定。


## 同时重写`equals`方法和`hashCode`方法

计算对象的哈希值的变量必须与`equals`一致。在重写`equals`方法后，必须以相同的方式重写`hashCode`方法，否则会导致依赖对象`hashCode`方法的行为与预期不符，例如`HashMap`，`HashSet`等。

重写`hashCode`方法的原则如下：
1. 在不修改`equals`相关的成员变量的情况下，每次调用`hashCode`方法的返回值应该一致。
2. 如果`x.equals(y)`为`true`，那么`x.hashCode()`与`y.hashCode()`必须相等。
3. 如果`x.equals(y)`为`false`，那么`x.hashCode()`与`y.hashCode()`可以不同，也可以相同，如果要产生更好的性能，尽量不通。

理想情况下，`hashCode`方法应该为不同对象产生不同的哈希值，下面这种方法可以给出相近的效果。

1. 选择一个非 0 值作为初始值，比如 17，赋值给`result`；
2.a 对于每一个待计算哈希值的变量，按照如下规则计算：
   - 1）如果类型是`boolean`，计算`f ? 1 : 0`；
   - 2）如果类型是`byte`，`char`

第一步选择一个非 0 的初始值，是为了让 2.a 为 0 的初始域影响到哈希值，进而增加减少哈希值冲突（考虑一个集合中有多种类型，这多种类型是都集继承自一个父类，计算哈希值的初始域为 0，每个子类的非零初始值选择不一样）。在 2.b 中选择使用 31 来计算哈希值，有两个原因，其中一个原因是必须选择一个非 0 值来计算，减少冲突（考虑相同字母异序字符串，如果不使用非 0 值，将会计算出相同的哈希值），另一个原因是`31 * i == (i << 5) - i`，计算性能更高。

## 始终重写`toString`方法

按照具体实现类的需求重写`toString`方法，有助于该类更易使用，所以`toString`方法应该返回所有该类重要的字段信息。比如对于`PhoneNumber`，`toString`方法的返回值

## 

